
func syncQemuDeployStatus(kClient *kuberentes.Client, pClient *proxmox.Client, qemu v1alpha1.Qemu) (v1alpha1.Qemu, error) {
	if !isQemuPlaced(qemu) {
		return qemu, nil
	}

	pendingConfig, err := pClient.Cluster(qemu.Status.Cluster).Node(qemu.Status.Node).Qemu().GetPendingConfig(qemu.Status.VmId)
	if err != nil {
		qemu.Status.Deploy = v1alpha1.STATUS_DEPLOY_ERROR
		qemu, err = kClient.V1alpha1().Qemu().UpdateStatus(qemu)
		if err != nil {
			return qemu, err
		}
		return qemu, fmt.Errorf("cannot get pending config: %s", err)
	}

	var isPending bool
	for _, v := range pendingConfig {
		if v.Pending != nil {
			log.Warnf("Qemu %s is in pending state, %s: %v != %v", qemu.Metadata.Name, v.Key, v.Value, v.Pending)
			isPending = true
		}
	}

	if isPending {
		qemu.Status.Deploy = v1alpha1.STATUS_DEPLOY_PENDING
		qemu, err = kClient.V1alpha1().Qemu().UpdateStatus(qemu)
		if err != nil {
			qemu.Status.Deploy = v1alpha1.STATUS_DEPLOY_ERROR
			qemu, err = kClient.V1alpha1().Qemu().UpdateStatus(qemu)
			if err != nil {
				return qemu, err
			}
			return qemu, err
		}

		return qemu, nil
	}

	currentConfig, err := pClient.Cluster(qemu.Status.Cluster).Node(qemu.Status.Node).Qemu().GetConfig(qemu.Status.VmId)
	if err != nil {
		qemu.Status.Deploy = v1alpha1.STATUS_DEPLOY_ERROR
		qemu, err = kClient.V1alpha1().Qemu().UpdateStatus(qemu)
		if err != nil {
			return qemu, err
		}
		return qemu, err
	}

	designConfig, err := buildQemuConfig(pClient, qemu)
	if err != nil {
		qemu.Status.Deploy = v1alpha1.STATUS_DEPLOY_ERROR
		qemu, err = kClient.V1alpha1().Qemu().UpdateStatus(qemu)
		if err != nil {
			return qemu, err
		}
		return qemu, err
	}

	var outOfSync bool
	for k, v := range designConfig {
		if k == "node" || k == "vmid" {
			continue
		}
		if fmt.Sprint(currentConfig[k]) != fmt.Sprint(v) {
			log.Warnf("Qemu %s is out of sync, %s: %v != %v", qemu.Metadata.Name, k, currentConfig[k], v)
			outOfSync = true
		}
	}

	var syncFail bool
	if outOfSync {
		err = setQemuConfig(kClient, pClient, qemu)
		if err != nil {
			qemu.Status.Deploy = v1alpha1.STATUS_DEPLOY_ERROR
			qemu, err = kClient.V1alpha1().Qemu().UpdateStatus(qemu)
			if err != nil {
				return qemu, err
			}
			syncFail = true
		}
	}

	if syncFail {
		qemu.Status.Deploy = v1alpha1.STATUS_DEPLOY_NOT_SYNCED
	} else {
		qemu.Status.Deploy = v1alpha1.STATUS_DEPLOY_DEPLOYED
	}

	qemu, err = kClient.V1alpha1().Qemu().UpdateStatus(qemu)
	if err != nil {
		qemu.Status.Deploy = v1alpha1.STATUS_DEPLOY_ERROR
		qemu, err = kClient.V1alpha1().Qemu().UpdateStatus(qemu)
		if err != nil {
			return qemu, err
		}
		return qemu, err
	}

	return qemu, nil
}




func syncQemuDisksStatus(kClient *kuberentes.Client, pClient *proxmox.Client, qemu v1alpha1.Qemu) (v1alpha1.Qemu, error) {
	if !isQemuPlaced(qemu) {
		return qemu, nil
	}

	qemuConfig, err := pClient.Cluster(qemu.Status.Cluster).Node(qemu.Status.Node).Qemu().GetConfig(qemu.Status.VmId)
	if err != nil {
		return qemu, err
	}

	rDiskSize := regexp.MustCompile(`^.+size=(.+),?$`)
	for _, disk := range qemu.Spec.Disk {
		var designStorageConfig proxmox.StorageConfig
		designStorageConfig, err = buildStorageConfig(pClient, qemu)
		if err != nil {
			return qemu, fmt.Errorf("cannot build storage config: %s", err)
		}

		for k, v := range qemuConfig {
			if strings.Contains(fmt.Sprint(v), designStorageConfig.Filename) {
				currentSize := rDiskSize.FindStringSubmatch(fmt.Sprint(v))
				if len(currentSize) != 2 {
					return qemu, fmt.Errorf("cannot extract disk num: %s", disk.Name)
				}
				if designStorageConfig.Size != currentSize[1] {
					err = pClient.Cluster(qemu.Status.Cluster).Node(qemu.Status.Node).Qemu().Resize(qemu.Status.VmId, k, designStorageConfig.Size)
					if err != nil {
						return qemu, fmt.Errorf("cannot resize qemu disk: %s", err)
					}
				}
			}
		}
	}

	return qemu, nil
}

func setQemuConfig(kClient *kuberentes.Client, pClient *proxmox.Client, qemu v1alpha1.Qemu) error {
	qemuConfig, err := buildQemuConfig(pClient, qemu)
	if err != nil {
		return err
	}

	err = pClient.Cluster(qemu.Status.Cluster).Node(qemu.Status.Node).Qemu().SetConfig(qemuConfig)
	if err != nil {
		return err
	}

	return nil
}


func isQemuPlaced(qemu v1alpha1.Qemu) bool {
	if qemu.Status.Cluster != "" && qemu.Status.Node != "" && qemu.Status.VmId != 0 {
		return true
	}

	return false
}
